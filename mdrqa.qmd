# Multidimensional Recurrence Quantification Analysis

Here you will find 6 exercises to learn different aspects of MdRQA and
some questions to discuss. 
Copy the codes to RStudio, set the working directory to 06_MdRQA (setwd),
and run the codes to look for the solutions. 
(Make sure you have 'crqa' and 'ggplot2' installed)

1.  Performing MdRQA on the Lorenz system. How do the results differ
    from those found using RQA? For what reasons?

```{r}
#| eval: false

# set path...
setwd("...")

# load package crqa
library(crqa)
library(ggplot2)

# Run MdRQA on the 3d-Lorenz system

# load data
Lorenz <- read.csv("Lorenz.csv")

# run MdRQA
res <- crqa(ts1=Lorenz, ts2=Lorenz, delay=1, embed=1, radius=1.5,
            normalize=0, tw=1, method="mdcrqa")

# check out recurrence measures
head(res)

# plot RP
RP <- res$RP
plot_rp(RP, xlabel = "Time", ylabel = "Time", geom = "void") + geom_point(size = 0.5)
```

2.  The differences between a Theiler Window (tw) of 1 and 0.

    Adjust the code above to check.

    What measures were more affected by the change?

    Would you choose the same Theiler Window for CRQA?

3.  The effects of noise on MdRQA outcomes.

    How did the RP and the recurrence measures change?

    What could you do to receive more informative MdRQA outcomes?

```{r}
#| eval: false

# load package crqa
library(crqa)

# load data
Lorenz <- read.csv("Lorenz.csv")
# load noisy data
noisy_Lorenz <- read.csv("R.csv")

# add R to Lorenz data.frame
Lorenz$r <- noisy_Lorenz$R

# run MdRQA
res <- crqa(ts1=Lorenz, ts2=Lorenz, delay=1, embed=1, radius=1.5,
            normalize=0, tw=1, method="mdcrqa")

# check out recurrence measures
head(res)

# plot RP
RP <- res$RP
plot_rp(RP, xlabel = "Time", ylabel = "Time", geom = "void") + geom_point(size = 0.5)
```

4.  The effect of data normalization in MdRQA.

Load the file R.csv and add it to the Lorenz-data.frame as fourth
variable. However, now use the scale() function to z-score the data from
the R.csv-file before adding it as fourth variable to the Lorenz data
frame.

How do the results change?

```{r}
#| eval: false

# load package crqa
library(crqa)

# load data
Lorenz <- read.csv("Lorenz.csv")
# load noisy data
noisy_Lorenz <- read.csv("R.csv")

# z-score R
noisy_Lorenz <- scale(noisy_Lorenz$R)

# add R to Lorenz data.frame
Lorenz$r <- noisy_Lorenz

# run MdRQA
res <- crqa(ts1=Lorenz, ts2=Lorenz, delay=1, embed=1, radius=1.5,
            normalize=0, tw=1, method="mdcrqa")

# check out recurrence measures
head(res)

# plot RP
RP <- res$RP
plot_rp(RP, xlabel = "Time", ylabel = "Time", geom = "void") + geom_point(size = 0.5)
```

5.  Rerun MdRQA on the Lorenz system with z-scored data (normalize = 2).
    Find a radius that yields %REC=5-10%.

```{r}
#| eval: false

# load package crqa
library(crqa)
library(ggplot2)

# Run MdRQA on the 3d-Lorenz system

# load data
Lorenz <- read.csv("Lorenz.csv")

# run MdRQA
res <- crqa(ts1=Lorenz, ts2=Lorenz, delay=1, embed=1, radius=1.2,
            normalize=2, tw=1, method="mdcrqa")

# check out recurrence measures
head(res)

# plot RP (it takes a minute here)
RP <- res$RP
plot_rp(RP, xlabel = "Time", ylabel = "Time", geom = "void") + geom_point(size = 0.5)
```

6.  Use Lagged MdRQA to find the lags in the Lorenz system, inspect the Lorenz time series.
    Do the lags seem reasonable?
    Use the lagged MdRQA wrapper. Here we resample the Lorenz system for a quicker computation.

First run the Lagged MdRQA function: (no need to dive in)
Then use the next code for the task.

```{r}
#| eval: false
# Install relevant package
install.packages('tcpl')

laggedMdrqa <- function(maxlag, ts1, ts2, delay, embed, rescale,
                        radius, normalize, mindiagline, minvertline, tw, method) {
  # Note:
  # This function wraps the crqa()-function from 'crqa' package.
  # In order to run the function, the packages 'crqa' and 'tcpl',
  # as well as their dependencies, need to be installed and loaded.
  # The authors give no warranty for the correct functioning of the software and cannot be held legally accountable.

# load libraries
library(tcpl)
library(crqa)

# infer parameters to create empty matrix
noTs <- dim(ts1)[2]
lagList <- matrix(0, ncol = noTs+1, nrow = (maxlag+1)^noTs)

# compute list of lag combinations
for(i in 1:noTs) {
    lagList[,i] <-rep(0:maxlag, each = (maxlag+1)^(i-1), (maxlag+1)^(noTs-i))
}

# equate lags on lag0
for(i in 1:(maxlag+1)^noTs) {
  lagList[i,1:noTs] <- lagList[i,1:noTs]-min(lagList[i,1:noTs])
}

# compute lag identifier
for(i in 1:noTs) {
  lagList[,noTs+1] <- lagList[,noTs+1] + lagList[,i]*100^(noTs-i)
}

# discard all lags that are not unique
lagList <- subset(lagList, duplicated(lagList[,noTs+1]) == FALSE)

# create results matrix and add lag parameters
results <- matrix(nrow = dim(lagList)[1], ncol = (9+dim(lagList)[2]-1))
results[,10:(10+(dim(lagList)[2]-2))] <- lagList[,1:(dim(lagList)[2]-1)]

# run lagged mdrqa
for(i in 1:dim(lagList)[1]) {
  
  # create temporary data matrix
  temp_ts1 <- matrix(ncol = dim(ts1)[2], nrow = length((1+lagList[i,1]):(dim(ts1)[1]-maxlag+lagList[i,1])))
  temp_ts2 <- matrix(ncol = dim(ts2)[2], nrow = length((1+lagList[i,1]):(dim(ts2)[1]-maxlag+lagList[i,1])))
  
  # construct lagged time series
  for(j in 1:dim(ts1)[2]) {
    temp_ts1[,j] <- ts1[(1+lagList[i,j]):(dim(ts1)[1]-maxlag+lagList[i,j]),j]
  }
  for(j in 1:dim(ts2)[2]) {
    temp_ts2[,j] <- ts2[(1+lagList[j,1]):(dim(ts2)[1]-maxlag+lagList[j,1]),j]
  }
  
  # rund mdrqa
        temp_res <- crqa(ts1=temp_ts1, ts2=temp_ts2, delay = delay, embed = embed,
                         rescale = rescale, radius = radius, normalize = normalize,
                         mindiagline = mindiagline, minvertline = minvertline,
                         tw = tw, method = "mdcrqa")
        
        # store recurrence measures on each iteration
        results[i,1:9] <- unlist(temp_res[1:9])
} 

# convert results to data frame
results <- as.data.frame(results)

# generate and add labels
newLabels <- c("RR","DER","NRLINE","maxL","L","ENTR","rENTR","LAM","TT")
j <- 0
for(i in 10:(10+(dim(lagList)[2]-2))) {
  j <- j+1
  newLabels[i] <- paste("ts",as.character(j),sep="")
}
colnames(results) <- newLabels

# sort data frame by RR
results <- results[order(results$RR, decreasing = TRUE),]

# return results
return(results)
}
```

Choose some value for the „maxlag“ parameter between 10-30. Investigate
the lag structure compared to the Lorenz system plot.

```{r}
#| eval: false

# load packages
library(crqa)
library(ggplot2)

#  Load Lorenz data
Lorenz <- read.csv("Lorenz.csv")
Lorenz$r <- 1:nrow(Lorenz)

# down-sample Lorenz data
down_Lorenz <- Lorenz[seq(1,2500,by=10),]

# plot down-sampled Lorenz data, dimension x

ggplot(down_Lorenz, aes(x = r)) +
  geom_line(aes(y = x, color = "x")) +
  geom_line(aes(y = y, color = "y")) +
  geom_line(aes(y = z, color = "z")) +
  labs(title = "Down-Sampled Lorenz") +
  ylab('') + xlab('') +
  theme_minimal() +
  scale_color_manual(values = c("x" = "red", "y" = "green", "z" = "blue"),
                     name = "Variables") +
  theme(legend.title = element_blank())


# run lagged Mdrqa - chose a value for maxlag between 10 and 30
res <- laggedMdrqa(maxlag = ...,
                   ts1 = down_Lorenz[,1:3],
                   ts2 = down_Lorenz[,1:3],
                   delay = 1,
                   embed = 1,
                   rescale = 0,
                   radius = 0.5,
                   normalize = 2,
                   mindiagline = 2,
                   minvertline = 2,
                   tw = 1,
                   method = "mdcrqa")

# plot RR-function
plot(res$RR, type = "l")

# investigate the first couple of lags
head(res)
```
