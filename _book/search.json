[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Nonlinear Methods Workshop Lecture Notes",
    "section": "",
    "text": "Preface\nOnline lecture notes for Nonlinear Methods Workshop held at Leuphana University in Lüneburg, 29 July – 2 August 2024.\nThere is also a PDF version of the lecture notes that can be downloaded.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction to recurrence plots",
    "section": "",
    "text": "1.1 A simple example\nWe start with the children’s rhyme by Helen H. Moore, shown below, to explore what recurrence in a time series is — exemplified here by the text, where each letter is a datum and time is represented by the position of the letter in the text.\nPop, pop, popcorn\nPopping in the pot!\nPop, pop, popcorn\nEat it while it's hot!\nPop, pop, popcorn\nButter on the top!\nWhen I eat popcorn\nI can't stop\nThe letters of the rhyme are encoded in the variable popcorn and we can the use the crqa() function from the package of the same name (Coco et al. 2021) to create the recurrence plot.\nThe first 30 elements of the popcorn vector are: P, O, P, ␣, P, O, P, ␣, P, O, P, C, O, R, N, ␣, P, O, P, P, I, N, G, ␣, I, N, ␣, T, H, E. Here the character “␣” represents a space between words. Line breaks and punctuation marks have been removed from the poem, and all letters are upper case, since we do not want to distinguish between lower case and upper case letters.\nThe R code shown below will compute and display the recurrence plot.\nlibrary(crqa)\n\nrp &lt;- crqa(popcorn, popcorn,\n           delay = 0,\n           embed = 0,\n           radius = 0.1,\n           method = \"rqa\",\n           datatype = \"categorical\")\n\nplot_rp(rp$RP)\n\n\n\n\nRecurrence plot of poem\nWe can also look at the first two verses of the poem, and put the letters on the axes, to make it a little easier to see how the underlying time series results in a recurrence plot.\nRecurrence plot of first two verses of the poem",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to recurrence plots</span>"
    ]
  },
  {
    "objectID": "intro.html#quantifying-the-recurrence-plot",
    "href": "intro.html#quantifying-the-recurrence-plot",
    "title": "1  Introduction to recurrence plots",
    "section": "1.2 Quantifying the recurrence plot",
    "text": "1.2 Quantifying the recurrence plot\nWith some training you can learn how to spot various properties of a time series simply by looking at the corresponding recurrence plot. In the case of the poem, we can see, for instance, that certain motifs are repeated in the poem. This is evident from the blue diagonal lines in the figure below, which correspond to the recurring motif “POP POP POPCORN”.\n\n\n\n\n\nRecurring motifs in the poem\n\n\n\n\nWhile we can gain some insights about the underlying time series from a visual inspection of the recurrence plot, we do not wish to rely on that. First, simply because we could overlook important features, and furthermore, it it not feasible for long time series or when comparing many time series. And, perhaps most importantly, we want objective measures, that do not depend on the skill of the person assessing the recurrence plot. With that said, it is still very useful to be able to visually inspect recurrence plots and infer something about the time series, so we definitely encourage you to work towards developing that skill as well.\nBut having objective quantitative measures that characterize features of a given recurrence plot is what has made recurrence plot analysis an effective tool, and that is why we will now look at recurrence quantification measures.\nSome of the most common recurrence quantification measures are reproduced in table Table 1.1, reproduced from Coco et al. (2021).\n\n\n\nTable 1.1: Common recurrence quantification measures\n\n\n\n\n\n\n\n\n\n\nMeasure\nAbbreviation\nDefinition\n\n\n\n\nRecurrence Rate\nRR\n\\(\\displaystyle \\frac{1}{N^2} \\sum_{i,j=1}^N R_{ij}\\)\n\n\nDeterminism\nDET\n\\(\\displaystyle \\left. \\sum_{l=l_\\mathrm{min}}^N lP(l) \\middle/ \\sum_{l=1}^N lP(l) \\right.\\)\n\n\nAverage Diagonal Line Length\nL\n\\(\\displaystyle \\left. \\sum_{l=l_\\mathrm{min}}^N lP(l) \\middle/ \\sum_{l=l_\\mathrm{min}}^N P(l) \\right.\\)\n\n\nMaximum Diagonal Line Length\nmaxL\n\\(\\displaystyle \\max(\\{l_i\\}_{i=1}^{N_l}), \\quad N_l = \\sum_{l\\geq l_\\mathrm{min}} P(l)\\)\n\n\nDiagonal Line Entropy\nENTR\n\\(\\displaystyle - \\sum_{l=l_\\mathrm{min}}^N p(l)\\log p(l)\\)\n\n\nLaminarity\nLAM\n\\(\\displaystyle \\left. \\sum_{v=v_\\mathrm{min}}^N vP(v) \\middle/ \\sum_{v=1}^N vP(v) \\right.\\)\n\n\nTrapping Time\nTT\n\\(\\displaystyle \\left. \\sum_{v=v_\\mathrm{min}}^N vP(v) \\middle/ \\sum_{v=v_\\mathrm{min}}^N P(v) \\right.\\)\n\n\nCategorical Area-based Entropy\ncatH\n\\(\\displaystyle - \\sum_{a&gt;1}^{N_a} p(a)\\log p(a)\\)\n\n\n\n\n\n\n\n\n\n\nCoco, Moreno I., Dan Mønster, Giuseppe Leonardi, Rick Dale, and Sebastian Wallot. 2021. “Unidimensional and Multidimensional Methods for Recurrence Quantification Analysis with Crqa.” The R Journal 13 (1): 145–63. https://doi.org/10.32614/RJ-2021-062.\n\n\nMarwan, Norbert, M. Carmen Romano, Marco Thiel, and Jürgen Kurths. 2007. “Recurrence Plots for the Analysis of Complex Systems.” Physics Reports 438 (56): 237–329. https://doi.org/10.1016/j.physrep.2006.11.001.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to recurrence plots</span>"
    ]
  },
  {
    "objectID": "rqa.html",
    "href": "rqa.html",
    "title": "2  Recurrence Quantification Analysis",
    "section": "",
    "text": "Under construction",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Recurrence Quantification Analysis</span>"
    ]
  },
  {
    "objectID": "crqa.html",
    "href": "crqa.html",
    "title": "3  Cross Recurrence Quantification Analysis",
    "section": "",
    "text": "Under construction",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Cross Recurrence Quantification Analysis</span>"
    ]
  },
  {
    "objectID": "mdrqa.html",
    "href": "mdrqa.html",
    "title": "4  Multidimensional Recurrence Quantification Analysis",
    "section": "",
    "text": "Here you will find 6 exercises to learn different aspects of MdRQA and some questions to discuss. Copy the codes to RStudio, set the working directory to 06_MdRQA (setwd), and run the codes to look for the solutions. (Make sure you have ‘crqa’ and ‘ggplot2’ installed)\n\nPerforming MdRQA on the Lorenz system. How do the results differ from those found using RQA? For what reasons?\n\n\n# set path...\nsetwd(\"...\")\n\n# load package crqa\nlibrary(crqa)\nlibrary(ggplot2)\n\n# Run MdRQA on the 3d-Lorenz system\n\n# load data\nLorenz &lt;- read.csv(\"Lorenz.csv\")\n\n# run MdRQA\nres &lt;- crqa(ts1=Lorenz, ts2=Lorenz, delay=1, embed=1, radius=1.5,\n            normalize=0, tw=1, method=\"mdcrqa\")\n\n# check out recurrence measures\nhead(res)\n\n# plot RP\nRP &lt;- res$RP\nplot_rp(RP, xlabel = \"Time\", ylabel = \"Time\", geom = \"void\") + geom_point(size = 0.5)\n\n\nThe differences between a Theiler Window (tw) of 1 and 0.\nAdjust the code above to check.\nWhat measures were more affected by the change?\nWould you choose the same Theiler Window for CRQA?\nThe effects of noise on MdRQA outcomes.\nHow did the RP and the recurrence measures change?\nWhat could you do to receive more informative MdRQA outcomes?\n\n\n# load package crqa\nlibrary(crqa)\n\n# load data\nLorenz &lt;- read.csv(\"Lorenz.csv\")\n# load noisy data\nnoisy_Lorenz &lt;- read.csv(\"R.csv\")\n\n# add R to Lorenz data.frame\nLorenz$r &lt;- noisy_Lorenz$R\n\n# run MdRQA\nres &lt;- crqa(ts1=Lorenz, ts2=Lorenz, delay=1, embed=1, radius=1.5,\n            normalize=0, tw=1, method=\"mdcrqa\")\n\n# check out recurrence measures\nhead(res)\n\n# plot RP\nRP &lt;- res$RP\nplot_rp(RP, xlabel = \"Time\", ylabel = \"Time\", geom = \"void\") + geom_point(size = 0.5)\n\n\nThe effect of data normalization in MdRQA.\n\nLoad the file R.csv and add it to the Lorenz-data.frame as fourth variable. However, now use the scale() function to z-score the data from the R.csv-file before adding it as fourth variable to the Lorenz data frame.\nHow do the results change?\n\n# load package crqa\nlibrary(crqa)\n\n# load data\nLorenz &lt;- read.csv(\"Lorenz.csv\")\n# load noisy data\nnoisy_Lorenz &lt;- read.csv(\"R.csv\")\n\n# z-score R\nnoisy_Lorenz &lt;- scale(noisy_Lorenz$R)\n\n# add R to Lorenz data.frame\nLorenz$r &lt;- noisy_Lorenz\n\n# run MdRQA\nres &lt;- crqa(ts1=Lorenz, ts2=Lorenz, delay=1, embed=1, radius=1.5,\n            normalize=0, tw=1, method=\"mdcrqa\")\n\n# check out recurrence measures\nhead(res)\n\n# plot RP\nRP &lt;- res$RP\nplot_rp(RP, xlabel = \"Time\", ylabel = \"Time\", geom = \"void\") + geom_point(size = 0.5)\n\n\nRerun MdRQA on the Lorenz system with z-scored data (normalize = 2). Find a radius that yields %REC=5-10%.\n\n\n# load package crqa\nlibrary(crqa)\nlibrary(ggplot2)\n\n# Run MdRQA on the 3d-Lorenz system\n\n# load data\nLorenz &lt;- read.csv(\"Lorenz.csv\")\n\n# run MdRQA\nres &lt;- crqa(ts1=Lorenz, ts2=Lorenz, delay=1, embed=1, radius=1.2,\n            normalize=2, tw=1, method=\"mdcrqa\")\n\n# check out recurrence measures\nhead(res)\n\n# plot RP (it takes a minute here)\nRP &lt;- res$RP\nplot_rp(RP, xlabel = \"Time\", ylabel = \"Time\", geom = \"void\") + geom_point(size = 0.5)\n\n\nUse Lagged MdRQA to find the lags in the Lorenz system, inspect the Lorenz time series. Do the lags seem reasonable? Use the lagged MdRQA wrapper. Here we resample the Lorenz system for a quicker computation.\n\nFirst run the Lagged MdRQA function: (no need to dive in) Then use the next code for the task.\n\nlaggedMdrqa &lt;- function(maxlag, ts1, ts2, delay, embed, rescale,\n                        radius, normalize, mindiagline, minvertline, tw, method) {\n  # Note:\n  # This function wraps the crqa()-function from 'crqa' package.\n  # In order to run the function, the package 'crqa',\n  # as well its dependencies, need to be installed and loaded.\n  # The authors give no warranty for the correct functioning of \n  # the software and cannot be held legally accountable.\n\n# load libraries\nlibrary(crqa)\n\n# infer parameters to create empty matrix\nnoTs &lt;- dim(ts1)[2]\nlagList &lt;- matrix(0, ncol = noTs+1, nrow = (maxlag+1)^noTs)\n\n# compute list of lag combinations\nfor(i in 1:noTs) {\n    lagList[,i] &lt;-rep(0:maxlag, each = (maxlag+1)^(i-1), (maxlag+1)^(noTs-i))\n}\n\n# equate lags on lag0\nfor(i in 1:(maxlag+1)^noTs) {\n  lagList[i,1:noTs] &lt;- lagList[i,1:noTs]-min(lagList[i,1:noTs])\n}\n\n# compute lag identifier\nfor(i in 1:noTs) {\n  lagList[,noTs+1] &lt;- lagList[,noTs+1] + lagList[,i]*100^(noTs-i)\n}\n\n# discard all lags that are not unique\nlagList &lt;- subset(lagList, duplicated(lagList[,noTs+1]) == FALSE)\n\n# create results matrix and add lag parameters\nresults &lt;- matrix(nrow = dim(lagList)[1], ncol = (9+dim(lagList)[2]-1))\nresults[,10:(10+(dim(lagList)[2]-2))] &lt;- lagList[,1:(dim(lagList)[2]-1)]\n\n# run lagged mdrqa\nfor(i in 1:dim(lagList)[1]) {\n  \n  # create temporary data matrix\n  temp_ts1 &lt;- matrix(ncol = dim(ts1)[2], nrow = length((1+lagList[i,1]):(dim(ts1)[1]-maxlag+lagList[i,1])))\n  temp_ts2 &lt;- matrix(ncol = dim(ts2)[2], nrow = length((1+lagList[i,1]):(dim(ts2)[1]-maxlag+lagList[i,1])))\n  \n  # construct lagged time series\n  for(j in 1:dim(ts1)[2]) {\n    temp_ts1[,j] &lt;- ts1[(1+lagList[i,j]):(dim(ts1)[1]-maxlag+lagList[i,j]),j]\n  }\n  for(j in 1:dim(ts2)[2]) {\n    temp_ts2[,j] &lt;- ts2[(1+lagList[j,1]):(dim(ts2)[1]-maxlag+lagList[j,1]),j]\n  }\n  \n  # rund mdrqa\n        temp_res &lt;- crqa(ts1=temp_ts1, ts2=temp_ts2, delay = delay, embed = embed,\n                         rescale = rescale, radius = radius, normalize = normalize,\n                         mindiagline = mindiagline, minvertline = minvertline,\n                         tw = tw, method = \"mdcrqa\")\n        \n        # store recurrence measures on each iteration\n        results[i,1:9] &lt;- unlist(temp_res[1:9])\n} \n\n# convert results to data frame\nresults &lt;- as.data.frame(results)\n\n# generate and add labels\nnewLabels &lt;- c(\"RR\",\"DER\",\"NRLINE\",\"maxL\",\"L\",\"ENTR\",\"rENTR\",\"LAM\",\"TT\")\nj &lt;- 0\nfor(i in 10:(10+(dim(lagList)[2]-2))) {\n  j &lt;- j+1\n  newLabels[i] &lt;- paste(\"ts\",as.character(j),sep=\"\")\n}\ncolnames(results) &lt;- newLabels\n\n# sort data frame by RR\nresults &lt;- results[order(results$RR, decreasing = TRUE),]\n\n# return results\nreturn(results)\n}\n\nChoose some value for the „maxlag“ parameter between 10-30. Investigate the lag structure compared to the Lorenz system plot.\n\n# load packages\nlibrary(crqa)\nlibrary(ggplot2)\n\n#  Load Lorenz data\nLorenz &lt;- read.csv(\"Lorenz.csv\")\nLorenz$r &lt;- 1:nrow(Lorenz)\n\n# down-sample Lorenz data\ndown_Lorenz &lt;- Lorenz[seq(1,2500,by=10),]\n\n# plot down-sampled Lorenz data, dimension x\n\nggplot(down_Lorenz, aes(x = r)) +\n  geom_line(aes(y = x, color = \"x\")) +\n  geom_line(aes(y = y, color = \"y\")) +\n  geom_line(aes(y = z, color = \"z\")) +\n  labs(title = \"Down-Sampled Lorenz\") +\n  ylab('') + xlab('') +\n  theme_minimal() +\n  scale_color_manual(values = c(\"x\" = \"red\", \"y\" = \"green\", \"z\" = \"blue\"),\n                     name = \"Variables\") +\n  theme(legend.title = element_blank())\n\n\n# run lagged Mdrqa - chose a value for maxlag between 10 and 30\nres &lt;- laggedMdrqa(maxlag = ...,\n                   ts1 = down_Lorenz[,1:3],\n                   ts2 = down_Lorenz[,1:3],\n                   delay = 1,\n                   embed = 1,\n                   rescale = 0,\n                   radius = 0.5,\n                   normalize = 2,\n                   mindiagline = 2,\n                   minvertline = 2,\n                   tw = 1,\n                   method = \"mdcrqa\")\n\n# plot RR-function\nplot(res$RR, type = \"l\")\n\n# investigate the first couple of lags\nhead(res)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Multidimensional Recurrence Quantification Analysis</span>"
    ]
  },
  {
    "objectID": "parameter_estimation.html",
    "href": "parameter_estimation.html",
    "title": "5  Parameter Estimation for RQA",
    "section": "",
    "text": "Under construction",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Parameter Estimation for RQA</span>"
    ]
  },
  {
    "objectID": "parameter_sensitivity.html",
    "href": "parameter_sensitivity.html",
    "title": "6  Parameter Sensitivity Analysis for RQA",
    "section": "",
    "text": "Assuming we are dealing with continuous time series rather than categorical time series, we estimate embedding parameters (delay and embedding dimension) as well as an appropriate radius parameter used to construct recurrence plots.\n\n# You may need to set the path here\nsetwd(\"\")\n\n# load packages\nlibrary(crqa)\nlibrary(dplyr)\nlibrary(ggplot2)\n\n# Load data files\n# You may need to change the path, depending on your working directory and where you have the file.\nload(\"../07_sample_analyses/dataSampleAnalysis_new.Rdata\")\n\n# Set the experimental condition\n# (o)ral reading = 0, (s)ilent reading = 1\nCON &lt;- factor(c(rep(0,6),rep(1,6))) \n\n# Enter the estimated parameters from the previous exercise\nopt_delay &lt;-  1\nopt_embed &lt;-  4\nopt_radius &lt;-  0.65\n\n# Now assign the part of parameter space to be explored\ndelay_values &lt;- seq(1, ...) # Set values here\nembed_values &lt;-             # Set values here\nradius_values &lt;-            # Set values here\n  \n# Start with an empty data frame for the RQA results and parameters\nexploration &lt;- data.frame()\n\nfor (d in delay_values) {\n  for (e in embed_values) {\n    for (r in radius_values) {\n      for(i in 1:12) {\n        # Note: we exclude the last data point\n        temp &lt;- crqa(ts1 = data[1:1098, i],\n                     ts2 = data[1:1098, i],\n                     rescale = 0,\n                     delay = d,\n                     embed = e,\n                     radius = r,\n                     normalize = 2,\n                     tw = 1,\n                     method = \"rqa\")\n        result &lt;- data.frame(\n          REC = temp$RR,\n          CON = CON[i],\n          delay = d,\n          embed = e,\n          radius = r\n        )\n        exploration &lt;- bind_rows(exploration, result)\n      }\n    }\n  }\n}\n\n# Compute exp_test which holds the results of the t-test for each set of\n# parameters.\nexp_test &lt;- data.frame()\n\nfor (d in delay_values) {\n  for (e in embed_values) {\n    for (r in radius_values) {\n      # Add t-test here\n      TT &lt;- t.test(REC ~ CON, \n                   data = exploration |&gt;\n                     filter(delay == d, embed == e, radius == r))\n      exp_test &lt;- bind_rows(\n        exp_test,\n        data.frame(\n          delay = d,\n          embed = e,\n          radius = r,\n          p_value = TT$p.value,\n          difference = TT$estimate[1] - TT$estimate[2],\n          CI_lo = TT$conf.int[1],\n          CI_hi = TT$conf.int[2]\n        )\n      )\n    }\n  }\n}\n\n# Add a variable for whether the t-test is significant\nexp_test &lt;- exp_test |&gt;\n  mutate(significant = (p_value &lt; 0.05))\n\n\n# Plot the result for the optimal parameters\nggplot(exploration |&gt; \n         filter(delay == opt_delay, \n                embed == opt_embed,\n                radius == opt_radius),\n       aes(x = CON, y = REC)) +\n  geom_boxplot() +\n  geom_point(aes(y = REC), position = position_jitter()) +\n  labs(title = \"Difference in conditions with chosen parameters\") +\n  theme_classic()\n\n\n\n# Same plot but as a violin plot\nggplot(exploration |&gt; \n         filter(delay == opt_delay, \n                embed == opt_embed,\n                radius == opt_radius),\n       aes(x = CON, y = REC)) +\n  geom_violin() +\n  geom_point(aes(y = REC), position = position_jitter()) +\n  labs(title = \"Difference in conditions with chosen parameters\") +\n  theme_classic()\n\n\n# Look at result of t-test for different values of embedding dimension\nggplot(exp_test |&gt; \n         filter(delay == opt_delay, radius == opt_radius),\n       aes(x = embed, y = p_value)) +\n  geom_hline(yintercept = 0.05, linetype = \"dashed\") +\n  geom_line() +\n  geom_point(data = exp_test |&gt; \n               filter(embed == opt_embed,\n                      radius == opt_radius,\n                      delay == opt_delay),\n             size = 4, colour = \"blue\") +\n  xlab(\"Embedding dimension\") +\n  ylab(\"p-value\") +\n  theme_bw()\n\n\nggplot(exp_test |&gt; \n         filter(delay == opt_delay, radius == opt_radius),\n       aes(x = embed, y = difference)) +\n  geom_hline(yintercept = 0, linetype = \"dashed\") +\n  geom_errorbar(aes(ymin = CI_lo, ymax = CI_hi)) +\n  geom_point() +\n  geom_point(data = exp_test |&gt; \n               filter(embed == opt_embed,\n                      radius == opt_radius,\n                      delay == opt_delay),\n             aes(y = difference),\n             size = 4, colour = \"blue\") +\n  xlab(\"Embedding dimension\") +\n  ylab(\"95% CI\") +\n  theme_bw()\n\n\n\n# Look at result of t-test for different values of delay\nggplot(exp_test |&gt; \n         filter(embed == opt_embed, radius == opt_radius),\n       aes(x = delay, y = p_value)) +\n  geom_hline(yintercept = 0.05, linetype = \"dashed\") +\n  geom_line() +\n  geom_point(data = exp_test |&gt; \n               filter(embed == opt_embed,\n                      radius == opt_radius,\n                      delay == opt_delay),\n             size = 4, colour = \"blue\") +\n  xlab(\"Delay\") +\n  ylab(\"p-value\") +\n  theme_bw()\n\n\nggplot(exp_test |&gt; \n         filter(embed == opt_embed, radius == opt_radius),\n       aes(x = delay, y = difference)) +\n  geom_hline(yintercept = 0, linetype = \"dashed\") +\n  geom_errorbar(aes(ymin = CI_lo, ymax = CI_hi)) +\n  geom_point() +\n  geom_point(data = exp_test |&gt; \n               filter(embed == opt_embed,\n                      radius == opt_radius,\n                      delay == opt_delay),\n             aes(y = difference),\n             size = 4, colour = \"blue\") +\n  xlab(\"Delay\") +\n  ylab(\"95% CI\") +\n  theme_bw()\n\n\n\n# Look at result of t-test for different values of radius\nggplot(exp_test |&gt; \n         filter(embed == opt_embed, delay == opt_delay),\n       aes(x = radius, y = p_value)) +\n  geom_hline(yintercept = 0.05, linetype = \"dashed\") +\n  geom_line() +\n  geom_point(data = exp_test |&gt; \n               filter(embed == opt_embed,\n                      radius == opt_radius,\n                      delay == opt_delay),\n             size = 4, colour = \"blue\") +\n  xlab(\"Radius\") +\n  ylab(\"p-value\") +\n  theme_bw()\n\n\nggplot(exp_test |&gt; \n         filter(embed == opt_embed, delay == opt_delay),\n       aes(x = radius, y = difference)) +\n  geom_hline(yintercept = 0, linetype = \"dashed\") +\n  geom_errorbar(aes(ymin = CI_lo, ymax = CI_hi)) +\n  geom_point() +\n  geom_point(data = exp_test |&gt; \n               filter(embed == opt_embed,\n                      radius == opt_radius,\n                      delay == opt_delay),\n             aes(y = difference),\n             size = 4, colour = \"blue\") +\n  xlab(\"Radius\") +\n  ylab(\"95% CI\") +\n  theme_bw()\n\n\n#\n# Keep radius fixed. Vary the other parameters.\n#\nggplot(exploration |&gt; filter(radius == opt_radius),\n       aes(x = CON, y = REC)) +\n  geom_rect(data = exp_test |&gt; filter(radius == opt_radius),\n            aes(fill = significant), inherit.aes = FALSE,\n            xmin = -Inf, xmax = Inf,\n            ymin = -Inf, ymax = Inf, alpha = 0.3) +\n  geom_rect(data = exp_test |&gt;\n              filter(embed == opt_embed,\n                     radius == opt_radius,\n                     delay == opt_delay),\n            colour = \"blue\", \n            linewidth = 1.5,\n            fill = NA,\n            inherit.aes = FALSE,\n            xmin = -Inf, xmax = Inf,\n            ymin = -Inf, ymax = Inf, alpha = 0.3) +\n  geom_violin() +\n  geom_point(position = position_jitter(),\n             size = 1, shape = \"o\") +\n  theme_classic() +\n  facet_grid(delay ~ embed) +\n  theme(legend.position = \"top\")\n\n\n# Same but with radius as facet instead of delay\nggplot(exploration |&gt; filter(delay == opt_delay),\n       aes(x = CON, y = REC)) +\n  geom_rect(data = exp_test |&gt; filter(delay == opt_delay),\n            aes(fill = significant), inherit.aes = FALSE,\n            xmin = -Inf, xmax = Inf,\n            ymin = -Inf, ymax = Inf, alpha = 0.3) +\n  geom_rect(data = exp_test |&gt;\n              filter(embed == opt_embed,\n                     radius == opt_radius,\n                     delay == opt_delay),\n            colour = \"blue\", \n            linewidth = 1.5,\n            fill = NA,\n            inherit.aes = FALSE,\n            xmin = -Inf, xmax = Inf,\n            ymin = -Inf, ymax = Inf, alpha = 0.3) +\n  # geom_boxplot() +\n  geom_violin() +\n  geom_point(position = position_jitter(),\n             size = 1, shape = \"o\") +\n  theme_classic() +\n  facet_grid(radius ~ embed) +\n  theme(legend.position = \"top\")\n\n\n\n# Same but with embedding fixed\nggplot(exploration |&gt; filter(embed == opt_embed),\n       aes(x = CON, y = REC)) +\n  geom_rect(data = exp_test |&gt; filter(embed == opt_embed),\n            aes(fill = significant), inherit.aes = FALSE,\n            xmin = -Inf, xmax = Inf,\n            ymin = -Inf, ymax = Inf, alpha = 0.3) +\n  geom_rect(data = exp_test |&gt;\n              filter(embed == opt_embed,\n                     radius == opt_radius,\n                     delay == opt_delay),\n            colour = \"blue\", \n            linewidth = 1.5,\n            fill = NA,\n            inherit.aes = FALSE,\n            xmin = -Inf, xmax = Inf,\n            ymin = -Inf, ymax = Inf, alpha = 0.3) +\n  # geom_boxplot() +\n  geom_violin() +\n  geom_point(position = position_jitter(),\n             size = 1, shape = \"o\") +\n  theme_classic() +\n  facet_grid(delay ~ radius) +\n  theme(legend.position = \"top\")",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Parameter Sensitivity Analysis for RQA</span>"
    ]
  },
  {
    "objectID": "fractal_analysis.html",
    "href": "fractal_analysis.html",
    "title": "7  Fractal Analysis",
    "section": "",
    "text": "Under construction",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Fractal Analysis</span>"
    ]
  },
  {
    "objectID": "ccm.html",
    "href": "ccm.html",
    "title": "8  Convergent Cross Mapping",
    "section": "",
    "text": "Under construction",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Convergent Cross Mapping</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Coco, Moreno I., Dan Mønster, Giuseppe Leonardi, Rick Dale, and\nSebastian Wallot. 2021. “Unidimensional and Multidimensional\nMethods for Recurrence Quantification Analysis with\nCrqa.” The R Journal 13 (1): 145–63. https://doi.org/10.32614/RJ-2021-062.\n\n\nMarwan, Norbert, M. Carmen Romano, Marco Thiel, and Jürgen Kurths. 2007.\n“Recurrence Plots for the Analysis of Complex Systems.”\nPhysics Reports 438 (56): 237–329. https://doi.org/10.1016/j.physrep.2006.11.001.",
    "crumbs": [
      "References"
    ]
  }
]